package dp;

/**
 * 70. 爬楼梯
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。（1 <= n <= 45）
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 *
 * 输入：n = 2
 * 输出：2
 * 解释：有两种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶
 * 2. 2 阶
 *
 * 输入：n = 3
 * 输出：3
 * 解释：有三种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶 + 1 阶
 * 2. 1 阶 + 2 阶
 * 3. 2 阶 + 1 阶
 */
public class ClimbStairs_70 {
    public static void main(String[] args) {
        int n = 3;
        System.out.println("爬楼梯结果:" + climbStairs(n));
    }

    /**
     * 动态规划；T:O(n) S:O(n)  可以像fib那样使用长度为2的数组进行空间优化，可以但没必要
     *                五部曲：①确定dp[i]数组以及下标的含义
     *                            dp[i]的定义为：爬到第i层楼梯，有dp[i]种方法
     *                       ②确定递推公式
     *                       （首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。
     *                       还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。
     *                       只取dp[i-1],dp[i-2]是因为只可以跳一步或者两步）
     *                            状态转移方程：dp[i]=dp[i-1]+dp[i-2]
     *                       ③dp数组的初始化（1 <= n <= 45）
     *                            dp[1]=1,dp[2]=2
     *                       ④确定遍历顺序
     *                            递推公式可以看出，遍历顺序一定是从前到后的
     *                       ⑤举例推导dp数组
     *                                  按照递归公式，当n为5时候，dp数组应该是下面的数列：
     *                                      1 2 3 5 8
     * @param n
     * @return
     */
    public static int climbStairs(int n) {
        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    /**
     * 爬楼梯进阶：
     *      改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？
     * @param n
     * @return
     */

    /**
     * 爬楼梯进阶：（完全背包问题）
     * 改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？
     * 动态规划；
     * 五部曲：①确定dp[i]数组以及下标的含义
     *           dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。
     *       ②确定递推公式
     *          求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];
     *          但是本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]
     *          那么递推公式为：dp[i] += dp[i - j]
     *      ③dp数组的初始化
     *           dp[0]=1
     *          非零下标初始化为0
     *      ④确定遍历顺序
     *          这是背包里求排列问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！
     *          需要先遍历target，再遍历nums
     *          每一步可以走多次，这是完全背包，内循环需要从前向后遍历。
     *      ⑤举例推导dp数组
     *          377类似
     *
     * @param n
     * @return
     */
    public static int climbStairsAdvanced(int n, int m) {//代码中m表示最多可以爬m个台阶，代码中把m改成2就是本题70.爬楼梯可以AC的代码了
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                if (i - j >= 0) {
                    dp[i] += dp[i - j];
                }
            }
        }
        return dp[n];
    }
}
