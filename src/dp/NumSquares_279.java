package dp;

/**
 * 279. 完全平方数
 * 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
 * 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
 *
 * 输入：n = 12
 * 输出：3
 * 解释：12 = 4 + 4 + 4
 *
 * 输入：n = 13
 * 输出：2
 * 解释：13 = 4 + 9
 */
public class NumSquares_279 {
    public static void main(String[] args) {

    }

    /**
     * 动态规划；完全背包
     *          题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？
     *
     *                五部曲：①确定dp[i]数组以及下标的含义
     *                            dp[j]的定义为：和为j的完全平方数的最少数量为dp[j]
     *                       ②确定递推公式
     *                            dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]
     *                            dp[j] = min(dp[j - i * i] + 1, dp[j]);
     *                       ③dp数组的初始化
     *                            dp[0]一定是0（看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, ...），题目描述中可没说要从0开始，dp[0]=0完全是为了递推公式）
     *                            从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，
     *                            所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖
     *                       ④确定遍历顺序
     *                            本题并不强调集合是组合还是排列，一般选取先遍历物品
     *                              （物品）放在外循环，（背包）在内循环。且内循环正序。
     *                       ⑤举例推导dp数组
     *                                 n为5
     *                                 dp[0] = 0 dp[1] = min(dp[0] + 1) = 1 dp[2] = min(dp[1] + 1) = 2
     *                                 dp[3] = min(dp[2] + 1) = 3 dp[4] = min(dp[3] + 1, dp[0] + 1) = 1 dp[5] = min(dp[4] + 1, dp[1] + 1) = 2
     *                                 dp[]  0  1  2  3  1  2
     * @param n
     * @return
     */
    public static int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        for (int k = 1; k < dp.length; k++) {
            dp[k] = Integer.MAX_VALUE;
        }

        for (int i = 1; i <= n; i++) {//遍历物品
            for (int j = 1; j <= n; j++) {//遍历背包
                if (j - i * i >= 0) {
                    dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
                }
            }
        }
        return dp[n];
    }
}
