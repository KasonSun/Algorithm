package dp;

/**
 * 96. 不同的二叉搜索树
 * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
 *
 * 输入：n = 3
 * 输出：5
 *
 * 输入：n = 1
 * 输出：1
 */
public class NumTrees_96 {
    public static void main(String[] args) {

    }
    /**
     * 动态规划；T:O(n^2) S:O(n)
     *                五部曲：①确定dp[i]数组以及下标的含义
     *                            dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
     *                       ②确定递推公式
     *                             dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
     *                             j相当于是头结点的元素，从1遍历到i为止。
     *                             所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量（注意是搜索树别忘了）
     *                       ③dp数组的初始化
     *                            dp[0]=1
     *                       ④确定遍历顺序
     *                            节点数为i的状态是依靠 i之前节点数的状态。那么遍历i里面每一个数作为头结点的状态，用j来遍历。
     *                       ⑤举例推导dp数组
     *                             n=5      0  1  2  3  4  5
     *                             dp[i]    1  1  2  5  14 42
     * @param n
     * @return
     */
    public static int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;//空节点也是二叉树
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
